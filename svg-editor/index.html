<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>SVG Editor — tylerlengyel.com</title>
<meta name="description" content="Lightweight in-browser SVG editor for createPhil outputs. No subscriptions, no build step." />
<style>
  /* === point-editing handles === */
.handle {
  position:absolute; width:10px; height:10px; margin:-5px 0 0 -5px;
  border-radius:50%; border:1px solid #69a7ff; background:#0b0b0d;
  box-shadow:0 0 0 2px rgba(105,167,255,.25);
  cursor:grab; z-index:10;
}
.handle:active { cursor:grabbing; }
  /* Site navbar (matches your main site) */
.site-nav{
  position: sticky; top: 0; z-index: 100;
  display:flex; gap:24px; justify-content:center; align-items:center;
  background: rgba(0,0,0,0.85);
  border-bottom: 1px solid rgba(155,255,176,0.25);
  padding: 10px 12px;
}
.site-nav a{
  color: #9bffb0; text-decoration: none; font-size: 20px;
}
.site-nav a:hover, .site-nav a:focus{ text-decoration: underline; }
  :root { --bg:#0b0b0d; --panel:#121216; --muted:#c8c8d0; --accent:#69a7ff; --text:#f2f2f5; --line:#1e1e25; --btn:#1b1b22; }
  * { box-sizing: border-box; }
  body { margin:0; background:var(--bg); color:var(--text); font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
  a { color: var(--accent); text-decoration: none; }
  .app { display:grid; grid-template-columns: 320px 1fr 320px; gap:12px; padding:12px; min-height:100vh; }
  .card { background:var(--panel); border:1px solid var(--line); border-radius:14px; padding:12px; }
  .h { margin:0 0 8px; font-weight:700; letter-spacing:.2px; }
  .subtle { color:#a9a9b3; font-size:12px; }
  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .col { display:flex; flex-direction:column; gap:8px; }
  .grid2 { display:grid; grid-template-columns:1fr 1fr; gap:8px; }
  input[type="text"], input[type="number"], textarea, .btn, .file {
    background:var(--btn); color:var(--text); border:1px solid var(--line); border-radius:10px; padding:8px 10px;
  }
  textarea { width:100%; height:160px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; }
  .btn { cursor:pointer; display:inline-flex; align-items:center; justify-content:center; gap:6px; white-space:nowrap; }
  .btn:active { transform: translateY(1px); }
  .btn.secondary { background:#101016; }
  .btn.danger { background:#2b171a; border-color:#412326; }
  .btn[disabled] { opacity:.45; cursor:not-allowed; transform:none; }
  .list { max-height:280px; overflow:auto; border:1px solid var(--line); border-radius:10px; padding:6px; }
  .list button { width:100%; text-align:left; background:transparent; border:0; color:var(--text); padding:6px 8px; border-radius:8px; cursor:pointer; }
  .list button:hover { background:#1a1a22; }
  .list .active { background:#20202a; }
  .canvas-wrap { position:relative; height:70vh; border:1px solid var(--line); border-radius:14px; overflow:hidden; background:#0e0e12; }
  .scene { position:absolute; inset:0; transform-origin:0 0; }
  .toolrow { display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap; }
  .small { font-size:12px; }
  .kbd { background:#222; border:1px solid var(--line); padding:0 6px; border-radius:6px; font-size:12px; color:#ddd; }
  .footer { text-align:center; padding:10px; color:#8a8aa0; }
  @media (max-width: 1024px) {
    .app { grid-template-columns: 1fr; }
  }
  .chip { display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border:1px solid var(--line); border-radius:999px; background:#101016;}
  .chip input { transform: translateY(1px); }
</style>
</head>
<body>
  <nav class="site-nav">
  <a href="/">Home</a>
  <a href="/writing.html">Hypotheses Page</a>
  <a href="/linearA/">Linear A</a>
  <a href="/createPhil/">createPhil</a>
  <a href="/svg-editor/">SVG Editor</a>
</nav>
<div class="app">
  <!-- LEFT: Load + Layers -->
  <section class="card col">
    <h2 class="h">Load SVG</h2>
    <div class="row">
      <input id="file" class="file" type="file" accept=".svg" />
      <button class="btn" id="btnUpload">Upload</button>
      <span class="subtle small">or paste into Source ↓</span>
    </div>

    <textarea id="source"></textarea>
    <div class="grid2">
      <button class="btn" id="btnApply">Apply source → editor</button>
      <button class="btn secondary" id="btnPull">Pull editor → source</button>
    </div>

    <div class="row" style="margin-top:8px;">
      <button class="btn secondary" id="btnUndo" title="Undo (⌘/Ctrl+Z)">⟲ Undo</button>
      <button class="btn secondary" id="btnRedo" title="Redo (⇧⌘/Ctrl+Z / Ctrl+Y)">⟳ Redo</button>
    </div>

    <div class="row">
      <button class="btn secondary" id="btnUndoView" title="View Undo (⌘/Ctrl+Alt+Z)">⟲ View Undo</button>
      <button class="btn secondary" id="btnRedoView" title="View Redo (⌘/Ctrl+Alt+⇧Z / Alt+Y)">⟳ View Redo</button>
      <span class="subtle small">Pan/Zoom history</span>
    </div>

    <div class="row">
      <label class="chip"><input id="clampToggle" type="checkbox" checked /> Clamp to viewBox (clip + clamp)</label>
    </div>

    <div class="subtle" style="margin-top:6px;">Tip: paste a createPhil SVG into the source box. “Apply” will parse it into the editor.</div>

    <h2 class="h" style="margin-top:12px;">Layers</h2>
    <div id="layers" class="list"></div>
  </section>

  <!-- CENTER: Canvas -->
  <section class="card">
    <h2 class="h">Canvas</h2>
    <div id="canvas" class="canvas-wrap">
      <div id="scene" class="scene"></div>
    </div>
    <div class="toolrow">
      <span class="small">Zoom: <span id="zoomVal">1.00×</span></span>
      <button class="btn secondary" id="btnReset">Reset View</button>
      <span class="small">Pan: hold <span class="kbd">Drag</span> / Zoom: <span class="kbd">Wheel</span></span>

      <button class="btn" id="btnEditPoints" title="Toggle edit vertices">✏️ Edit Points</button>
      <button class="btn secondary" id="btnPathToPolyline" title="Sample selected path into editable polyline">Convert path → polyline</button>
    </div>
  </section>

  <!-- RIGHT: Inspector + Export -->
  <section class="card col">
    <h2 class="h">Inspector</h2>
    <div id="selInfo" class="subtle">No element selected</div>
    <div class="grid2">
      <div class="col">
        <label for="fill">Fill</label>
        <input id="fill" type="text" placeholder="none | #000 | rgb()" />
      </div>
      <div class="col">
        <label for="stroke">Stroke</label>
        <input id="stroke" type="text" placeholder="#000" />
      </div>
      <div class="col">
        <label for="sw">Stroke Width</label>
        <input id="sw" type="number" step="0.5" />
      </div>
      <div class="col">
        <label for="op">Opacity</label>
        <input id="op" type="number" min="0" max="1" step="0.05" />
      </div>
    </div>

    <h3 class="h" style="margin-top:6px;">Transform</h3>
    <div class="grid2">
      <div class="col">
        <label for="tx">Translate X</label>
        <input id="tx" type="number" />
      </div>
      <div class="col">
        <label for="ty">Translate Y</label>
        <input id="ty" type="number" />
      </div>
      <div class="col">
        <label for="sc">Scale</label>
        <input id="sc" type="number" step="0.05" />
      </div>
      <div class="col">
        <label for="rt">Rotate (deg)</label>
        <input id="rt" type="number" step="1" />
      </div>
    </div>

    <div class="toolrow">
      <button class="btn danger" id="btnDelete">Delete selected</button>
    </div>

    <h2 class="h" style="margin-top:12px;">Export</h2>
    <div class="grid2">
      <button class="btn" id="btnSaveSvg">Download SVG</button>
      <button class="btn" id="btnSavePng">Download PNG</button>
    </div>
    <div class="subtle">PNG export uses the SVG’s viewBox/size and renders client-side.</div>
  </section>
</div>

<div class="footer small">Made for createPhil. No subscriptions, fully client-side.</div>

<script>
(() => {
  // --- State ---
  let currentSVG = null;
  let selectedEl = null;
  let layers = [];
  let zoom = 1;
  let pan = { x: 0, y: 0 };
  let isPanning = false;
  let last = { x: 0, y: 0 };
  let clampToViewBox = true;
  // --- Point editing state ---
  let editMode = false;
  let handles = [];

  // --- History (Content) ---
  const HISTORY_LIMIT = 100;
  const history = [];
  let histPtr = -1;
  let recordTimer = null;

  // --- History (View: pan/zoom) ---
  const VIEW_HISTORY_LIMIT = 100;
  const viewHistory = [];
  let viewPtr = -1;
  let viewRecordTimer = null;

  // --- DOM ---
  const source = document.getElementById('source');
  const file   = document.getElementById('file');
  const scene  = document.getElementById('scene');
  const canvas = document.getElementById('canvas');
  const layersBox = document.getElementById('layers');
  const selInfo = document.getElementById('selInfo');
  const zoomVal = document.getElementById('zoomVal');
  const clampToggle = document.getElementById('clampToggle');

  // Inspector inputs
  const $fill = document.getElementById('fill');
  const $stroke = document.getElementById('stroke');
  const $sw = document.getElementById('sw');
  const $op = document.getElementById('op');
  const $tx = document.getElementById('tx');
  const $ty = document.getElementById('ty');
  const $sc = document.getElementById('sc');
  const $rt = document.getElementById('rt');

  // Buttons
  const btnUndo = document.getElementById('btnUndo');
  const btnRedo = document.getElementById('btnRedo');
  const btnUndoView = document.getElementById('btnUndoView');
  const btnRedoView = document.getElementById('btnRedoView');
  const btnEditPoints = document.getElementById('btnEditPoints');
  const btnPathToPolyline = document.getElementById('btnPathToPolyline');

  document.getElementById('btnUpload').onclick = () => file.click();
  document.getElementById('btnApply').onclick = () => { setSVGFromText(source.value); };
  document.getElementById('btnPull').onclick = () => { if (currentSVG) source.value = serializeSVG(currentSVG); };
  document.getElementById('btnReset').onclick = () => { setView({x:0,y:0}, 1, true); };
  document.getElementById('btnDelete').onclick = () => { removeSelected(); pushHistory('delete'); };
  document.getElementById('btnSaveSvg').onclick = downloadSVG;
  document.getElementById('btnSavePng').onclick = downloadPNG;
  btnUndo.onclick = undo;
  btnRedo.onclick = redo;
  btnUndoView.onclick = undoView;
  btnRedoView.onclick = redoView;
  clampToggle.addEventListener('change', () => { clampToViewBox = clampToggle.checked; ensureClip(); });
  btnEditPoints.onclick = () => {
  editMode = !editMode;
  btnEditPoints.classList.toggle('secondary', !editMode);
  rebuildHandles();
};

btnPathToPolyline.onclick = () => {
  if (!selectedEl) return;
  if (selectedEl.tagName.toLowerCase() !== 'path') { alert('Select a <path> first.'); return; }
  const poly = pathToPolyline(selectedEl, 128); // sample 128 points
  selectedEl.replaceWith(poly);
  selectElement(poly);
  pushHistoryDebounced();
  rebuildHandles();
};

  // File upload
  file.addEventListener('change', async (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    const text = await f.text();
    source.value = text;
    setSVGFromText(text);
  });

  // Keyboard shortcuts: Content vs View
  window.addEventListener('keydown', (e) => {
    const key = e.key.toLowerCase();
    const meta = (e.ctrlKey || e.metaKey);

    if (!meta) return;

    // View history when Alt is held
    if (e.altKey) {
      if (key === 'z' && !e.shiftKey) { e.preventDefault(); undoView(); return; }
      if ((key === 'y') || (key === 'z' && e.shiftKey)) { e.preventDefault(); redoView(); return; }
    }

    // Content history (no Alt)
    if (key === 'z' && !e.shiftKey) { e.preventDefault(); undo(); return; }
    if ((key === 'y') || (key === 'z' && e.shiftKey)) { e.preventDefault(); redo(); return; }
  });

  // Canvas pan/zoom
  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const delta = -e.deltaY;
    const factor = delta > 0 ? 1.06 : 0.94;
    const nextZoom = Math.min(10, Math.max(0.1, zoom * factor));
    setView(pan, nextZoom); // record in view history (debounced)
  }, { passive:false });

  canvas.addEventListener('mousedown', (e) => {
    isPanning = true; last.x = e.clientX; last.y = e.clientY;
  });
  window.addEventListener('mouseup', () => isPanning = false);
  window.addEventListener('mousemove', (e) => {
    if (!isPanning) return;
    const nextPan = { x: pan.x + (e.clientX - last.x), y: pan.y + (e.clientY - last.y) };
    last.x = e.clientX; last.y = e.clientY;
    setView(nextPan, zoom); // record in view history (debounced)
  });

  function updateView() {
    scene.style.transform = `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`;
    zoomVal.textContent = zoom.toFixed(2) + '×';
  }

  // ---- View history helpers ----
  function pushViewDebounced() {
    clearTimeout(viewRecordTimer);
    viewRecordTimer = setTimeout(pushView, 120);
  }
  function pushView() {
    const state = { pan: { ...pan }, zoom };
    if (viewHistory.length && shallowEqualView(viewHistory[viewPtr], state)) return;
    if (viewPtr < viewHistory.length - 1) viewHistory.splice(viewPtr + 1);
    viewHistory.push(state);
    if (viewHistory.length > VIEW_HISTORY_LIMIT) viewHistory.shift();
    viewPtr = viewHistory.length - 1;
    updateViewButtons();
  }
  function shallowEqualView(a,b){ return a && b && a.zoom===b.zoom && a.pan.x===b.pan.x && a.pan.y===b.pan.y; }
  function undoView(){ if (viewPtr > 0){ applyView(viewHistory[viewPtr-1]); viewPtr--; updateViewButtons(); } }
  function redoView(){ if (viewPtr >=0 && viewPtr < viewHistory.length-1){ applyView(viewHistory[viewPtr+1]); viewPtr++; updateViewButtons(); } }
  function updateViewButtons(){
    btnUndoView.disabled = !(viewPtr > 0);
    btnRedoView.disabled = !(viewPtr >=0 && viewPtr < viewHistory.length-1);
  }
  function applyView(v){ pan = { ...v.pan }; zoom = v.zoom; updateView(); }
  function setView(nextPan, nextZoom, recordImmediate=false){
    pan = { ...nextPan }; zoom = nextZoom; updateView();
    if (editMode) rebuildHandles();
    if (recordImmediate) pushView(); else pushViewDebounced();
  }

  // ---- Content history ----
  function serializeSVG(svg) {
    return `<?xml version="1.0" encoding="UTF-8"?>\n` + new XMLSerializer().serializeToString(svg);
  }
  function pushHistoryDebounced() { clearTimeout(recordTimer); recordTimer = setTimeout(pushHistory, 200); }
  function pushHistory() {
    if (!currentSVG) return;
    const state = serializeCurrent();
    if (history.length && history[histPtr] === state) return;
    if (histPtr < history.length - 1) history.splice(histPtr + 1);
    history.push(state);
    if (history.length > HISTORY_LIMIT) history.shift();
    histPtr = history.length - 1;
    updateHistoryButtons();
  }
  function serializeCurrent() { return currentSVG ? serializeSVG(currentSVG) : ''; }
  function restoreFromHistory(index) {
    if (index < 0 || index >= history.length) return;
    const text = history[index];
    setSVGFromText(text, /*record*/ false);
    histPtr = index;
    updateHistoryButtons();
  }
  function canUndo() { return histPtr > 0; }
  function canRedo() { return histPtr >= 0 && histPtr < history.length - 1; }
  function undo() { if (canUndo()) restoreFromHistory(histPtr - 1); }
  function redo() { if (canRedo()) restoreFromHistory(histPtr + 1); }
  function updateHistoryButtons() {
    btnUndo.disabled = !canUndo();
    btnRedo.disabled = !canRedo();
  }

  // Parse SVG from text and mount into scene
  function setSVGFromText(text, record=true) {
    const svg = parseSVG(text);
    if (!svg) { alert('Could not parse SVG'); return; }
    if (!svg.getAttribute('xmlns')) svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');

    currentSVG = svg;
    ensureClip(); // set up initial clip if enabled
    scene.replaceChildren(svg);
    selectedEl = null;
    refreshLayers();
    bindSvgClicks();
    if (record) pushHistory();
    // Reset view history on new load (start fresh)
    viewHistory.length = 0; viewPtr = -1;
    setView({x:0,y:0}, 1, true);
  }

  function parseSVG(text) {
    try {
      const doc = new DOMParser().parseFromString(text, 'image/svg+xml');
      const svg = doc.querySelector('svg');
      return svg || null;
    } catch(_) { return null; }
  }

  // Layers
  function refreshLayers() {
    layers = flattenElements(currentSVG);
    layersBox.innerHTML = '';
    layers.forEach((el, i) => {
      const btn = document.createElement('button');
      btn.textContent = `${i}. <${el.tagName.toLowerCase()}> ${el.getAttribute('id') ? '#' + el.getAttribute('id') : ''}`;
      btn.onclick = () => selectElement(el, i);
      if (el === selectedEl) btn.classList.add('active');
      layersBox.appendChild(btn);
    });
    selInfo.textContent = selectedEl ?
      `Selected: <${selectedEl.tagName.toLowerCase()}> ${selectedEl.getAttribute('id') ? '#' + selectedEl.getAttribute('id') : ''}` :
      'No element selected';
    populateInspector();
  }

  function flattenElements(svg) {
    if (!svg) return [];
    const out = [];
    const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT, {
      acceptNode(node) {
        const tag = node.tagName && node.tagName.toLowerCase();
        if (['defs','title','desc','metadata'].includes(tag)) return NodeFilter.FILTER_REJECT;
        if (tag === 'svg') return NodeFilter.FILTER_SKIP;
        return NodeFilter.FILTER_ACCEPT;
      }
    });
    let n; while ((n = walker.nextNode())) out.push(n);
    return out;
  }

  function bindSvgClicks() {
    if (!currentSVG) return;
    currentSVG.addEventListener('click', (e) => {
      if (e.target === currentSVG) { selectElement(null); return; }
      const idx = layers.indexOf(e.target);
      if (idx >= 0) selectElement(e.target, idx);
    });
  }

  function selectElement(el, idx = -1) {
    selectedEl = el;
    refreshLayers();
    rebuildHandles();   // keep handles in sync with selection
  }

  // Inspector <-> element
  function getAttr(el, name, fallback='') { return el ? (el.getAttribute(name) ?? fallback) : ''; }
  function setAttr(el, name, value) {
    if (!el) return;
    if (value === '' || value === null || value === undefined) el.removeAttribute(name);
    else el.setAttribute(name, String(value));
  }

  function parseTransform(el) {
    const t = getAttr(el, 'transform', '');
    const res = { x:0, y:0, scale:1, rotate:0 };
    const re = /(translate|scale|rotate)\(([^)]*)\)/g;
    let m;
    while ((m = re.exec(t))) {
      const kind = m[1]; const nums = m[2].split(/[ ,]+/).map(Number);
      if (kind === 'translate') { res.x = nums[0]||0; res.y = nums[1]||0; }
      if (kind === 'scale')     { res.scale = nums[0]||1; }
      if (kind === 'rotate')    { res.rotate = nums[0]||0; }
    }
    return res;
  }

  function applyTransform(el, tx) {
    // Try applying, clamp to viewBox if enabled, then finalize
    const vb = readViewBox(currentSVG);
    if (!vb) {
      setAttr(el, 'transform', buildTransform(tx));
      return;
    }

    const proposed = { ...tx };
    // Temporarily set to measure bbox post-transform
    const prev = el.getAttribute('transform');
    el.setAttribute('transform', buildTransform(proposed));

    if (clampToViewBox) {
      try {
        const bb = el.getBBox(); // post-transform bbox
        const [vx, vy, vw, vh] = vb;
        let dx = 0, dy = 0;

        if (bb.x < vx) dx = vx - bb.x;
        if (bb.x + bb.width > vx + vw) dx = (vx + vw) - (bb.x + bb.width);
        if (bb.y < vy) dy = vy - bb.y;
        if (bb.y + bb.height > vy + vh) dy = (vy + vh) - (bb.y + bb.height);

        if (dx || dy) {
          proposed.x += dx;
          proposed.y += dy;
          el.setAttribute('transform', buildTransform(proposed));
        }
      } catch (_) {
        // Some elements may not have bbox; fallback to proposed as-is
      }
    }
  }
  // ====== HANDLE RENDERING ======
function clearHandles(){
  handles.forEach(h => h.remove());
  handles = [];
}
function rebuildHandles(){
  clearHandles();
  if (!editMode || !selectedEl || !currentSVG) return;
  const tag = selectedEl.tagName.toLowerCase();
  if (tag === 'polygon' || tag === 'polyline') addVertexHandlesForPoints(selectedEl);
  else if (tag === 'rect') addHandlesForRect(selectedEl);
  else if (tag === 'circle') addHandlesForCircle(selectedEl);
  else if (tag === 'ellipse') addHandlesForEllipse(selectedEl);
  // paths are handled via conversion
}

function svgPT(svg, x, y){
  const pt = svg.createSVGPoint(); pt.x = x; pt.y = y;
  const m = svg.getScreenCTM();
  const p = pt.matrixTransform(m);
  return { x:p.x, y:p.y };
}
function inverseClientToSVG(svg, clientX, clientY){
  const pt = svg.createSVGPoint(); pt.x = clientX; pt.y = clientY;
  const m = (svg.getScreenCTM() || svg.getCTM()).inverse();
  const p = pt.matrixTransform(m);
  return { x:p.x, y:p.y };
}
function placeHandleAt(svg, x, y, onDrag){
  const sceneEl = document.getElementById('scene'); // absolute parent
  const screen = svgPT(svg, x, y);
  const h = document.createElement('div');
  h.className = 'handle';
  h.style.left = screen.x + 'px';
  h.style.top  = screen.y + 'px';
  sceneEl.appendChild(h);
  handles.push(h);

  let dragging = false;
  function onMove(ev){
    if (!dragging) return;
    const { x:svgX, y:svgY } = inverseClientToSVG(svg, ev.clientX, ev.clientY);
    onDrag(svgX, svgY);
    // keep handle glued to new spot
    const screen2 = svgPT(svg, svgX, svgY);
    h.style.left = screen2.x + 'px';
    h.style.top  = screen2.y + 'px';
  }
  h.addEventListener('mousedown', (ev)=>{ dragging = true; ev.preventDefault(); window.addEventListener('mousemove', onMove); });
  window.addEventListener('mouseup', ()=>{ if (dragging){ dragging=false; window.removeEventListener('mousemove', onMove); pushHistoryDebounced(); }});
  return h;
}

// --- polygon/polyline ---
function parsePointsAttr(el){
  const raw = (el.getAttribute('points') || '').trim();
  if (!raw) return [];
  return raw.split(/[\s,]+/).reduce((acc, v, i, arr)=>{
    if (i % 2 === 0) acc.push({ x: parseFloat(arr[i]), y: parseFloat(arr[i+1]) });
    return acc;
  }, []);
}
function writePointsAttr(el, pts){
  el.setAttribute('points', pts.map(p => `${p.x},${p.y}`).join(' '));
}
function addVertexHandlesForPoints(el){
  const svg = currentSVG;
  const pts = parsePointsAttr(el);
  pts.forEach((p, idx) => {
    placeHandleAt(svg, p.x, p.y, (nx, ny) => {
      pts[idx].x = nx; pts[idx].y = ny;
      writePointsAttr(el, pts);
    });
  });
}

// --- rect (edit via 4 corners) ---
function addHandlesForRect(el){
  const svg = currentSVG;
  let x = +el.getAttribute('x') || 0;
  let y = +el.getAttribute('y') || 0;
  let w = +el.getAttribute('width') || 0;
  let h = +el.getAttribute('height') || 0;

  const corners = [
    {name:'tl', x:x,     y:y    },
    {name:'tr', x:x+w,   y:y    },
    {name:'br', x:x+w,   y:y+h  },
    {name:'bl', x:x,     y:y+h  },
  ];
  corners.forEach((c, i)=>{
    placeHandleAt(svg, c.x, c.y, (nx, ny) => {
      if (i===0){ // tl
        w += (x - nx); h += (y - ny); x = nx; y = ny;
      } else if (i===1){ // tr
        w = (nx - x); h += (y - ny); y = ny;
      } else if (i===2){ // br
        w = (nx - x); h = (ny - y);
      } else { // bl
        w += (x - nx); x = nx; h = (ny - y);
      }
      if (w<0){ x += w; w = -w; }
      if (h<0){ y += h; h = -h; }
      el.setAttribute('x', x); el.setAttribute('y', y);
      el.setAttribute('width',  w); el.setAttribute('height', h);
      rebuildHandles(); // reposition other handles
    });
  });
}

// --- circle (center + radius handle) ---
function addHandlesForCircle(el){
  const svg = currentSVG;
  let cx = +el.getAttribute('cx') || 0;
  let cy = +el.getAttribute('cy') || 0;
  let r  = +el.getAttribute('r')  || 0;

  // center
  placeHandleAt(svg, cx, cy, (nx, ny) => {
    cx = nx; cy = ny;
    el.setAttribute('cx', cx); el.setAttribute('cy', cy);
    rebuildHandles();
  });
  // radius (drag any direction)
  placeHandleAt(svg, cx + r, cy, (nx, ny) => {
    r = Math.hypot(nx - cx, ny - cy);
    el.setAttribute('r', r);
    rebuildHandles();
  });
}

// --- ellipse (center + rx handle + ry handle) ---
function addHandlesForEllipse(el){
  const svg = currentSVG;
  let cx = +el.getAttribute('cx') || 0;
  let cy = +el.getAttribute('cy') || 0;
  let rx = +el.getAttribute('rx') || 0;
  let ry = +el.getAttribute('ry') || 0;

  placeHandleAt(svg, cx, cy, (nx, ny) => {
    cx = nx; cy = ny;
    el.setAttribute('cx', cx); el.setAttribute('cy', cy);
    rebuildHandles();
  });
  placeHandleAt(svg, cx + rx, cy, (nx) => {
    rx = Math.abs(nx - cx); el.setAttribute('rx', rx); rebuildHandles();
  });
  placeHandleAt(svg, cx, cy + ry, (_nx, ny) => {
    ry = Math.abs(ny - cy); el.setAttribute('ry', ry); rebuildHandles();
  });
}

// ====== PATH → POLYLINE SAMPLER ======
function pathToPolyline(pathEl, samples = 128){
  const path = pathEl;
  const len = path.getTotalLength();
  const pts = [];
  for (let i=0; i<samples; i++){
    const p = path.getPointAtLength((i/(samples-1)) * len);
    pts.push(`${p.x},${p.y}`);
  }
  const pl = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
  pl.setAttribute('points', pts.join(' '));
  // copy some presentational attrs
  ['fill','stroke','stroke-width','opacity','transform'].forEach(a=>{
    const v = path.getAttribute(a); if (v!=null) pl.setAttribute(a, v);
  });
  return pl;
}

  function buildTransform(t) {
    const parts = [];
    if (t.x || t.y) parts.push(`translate(${t.x},${t.y})`);
    if (t.rotate) parts.push(`rotate(${t.rotate})`);
    if (t.scale !== 1) parts.push(`scale(${t.scale})`);
    return parts.join(' ');
  }

  function populateInspector() {
    if (!selectedEl) {
      [$fill,$stroke,$sw,$op,$tx,$ty,$sc,$rt].forEach(i => i.value = '');
      return;
    }
    $fill.value = getAttr(selectedEl,'fill','');
    $stroke.value = getAttr(selectedEl,'stroke','');
    $sw.value = getAttr(selectedEl,'stroke-width','');
    $op.value = getAttr(selectedEl,'opacity','');

    const tx = parseTransform(selectedEl);
    $tx.value = tx.x; $ty.value = tx.y; $sc.value = tx.scale; $rt.value = tx.rotate;
  }

  function hookupInspector() {
    $fill.addEventListener('input', () => { if (selectedEl) { setAttr(selectedEl,'fill',$fill.value||null); pushHistoryDebounced(); }});
    $stroke.addEventListener('input', () => { if (selectedEl) { setAttr(selectedEl,'stroke',$stroke.value||null); pushHistoryDebounced(); }});
    $sw.addEventListener('input', () => { if (selectedEl) { setAttr(selectedEl,'stroke-width',$sw.value||null); pushHistoryDebounced(); }});
    $op.addEventListener('input', () => { if (selectedEl) { setAttr(selectedEl,'opacity',$op.value||null); pushHistoryDebounced(); }});

    $tx.addEventListener('input', () => { if (selectedEl) { const t=parseTransform(selectedEl); t.x=Number($tx.value||0); applyTransform(selectedEl,t); pushHistoryDebounced(); }});
    $ty.addEventListener('input', () => { if (selectedEl) { const t=parseTransform(selectedEl); t.y=Number($ty.value||0); applyTransform(selectedEl,t); pushHistoryDebounced(); }});
    $sc.addEventListener('input', () => { if (selectedEl) { const t=parseTransform(selectedEl); t.scale=Number($sc.value||1); applyTransform(selectedEl,t); pushHistoryDebounced(); }});
    $rt.addEventListener('input', () => { if (selectedEl) { const t=parseTransform(selectedEl); t.rotate=Number($rt.value||0); applyTransform(selectedEl,t); pushHistoryDebounced(); }});
  }
  hookupInspector();

  function removeSelected() {
    if (!selectedEl || !selectedEl.parentElement) return;
    selectedEl.parentElement.removeChild(selectedEl);
    selectedEl = null;
    refreshLayers();
  }

  // Export
  function downloadSVG() {
    if (!currentSVG) return;
    const text = serializeSVG(currentSVG);
    const blob = new Blob([text], { type: 'image/svg+xml;charset=utf-8' });
    triggerDownload(blob, 'export.svg');
  }

  async function downloadPNG() {
    if (!currentSVG) return;
    const text = serializeSVG(currentSVG);
    const svgBlob = new Blob([text], { type: 'image/svg+xml;charset=utf-8' });
    const url = URL.createObjectURL(svgBlob);
    const img = new Image();
    img.decoding = 'async';
    img.crossOrigin = 'anonymous';
    await new Promise((res, rej) => { img.onload = res; img.onerror = rej; img.src = url; });

    // width/height from viewBox or attributes
    const vb = readViewBox(currentSVG);
    const w = vb ? vb[2] : Number(currentSVG.getAttribute('width') || 420);
    const h = vb ? vb[3] : Number(currentSVG.getAttribute('height') || 420);

    const scale = 3; // 3x for crisper png
    const canvasEl = document.createElement('canvas');
    canvasEl.width = Math.max(1, Math.round(w * scale));
    canvasEl.height = Math.max(1, Math.round(h * scale));
    const ctx = canvasEl.getContext('2d');
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(img, 0, 0, canvasEl.width, canvasEl.height);
    URL.revokeObjectURL(url);

    canvasEl.toBlob((blob) => triggerDownload(blob, 'export.png'), 'image/png');
  }

  function triggerDownload(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename; a.click();
    URL.revokeObjectURL(url);
  }

  // viewBox helpers & clip
  function readViewBox(svg){
    if (!svg) return null;
    const v = (svg.getAttribute('viewBox')||'').split(/\s+/).map(Number);
    if (v.length===4 && v.every(n=>!Number.isNaN(n))) return v;
    // fallback to width/height
    const w = Number(svg.getAttribute('width')||420);
    const h = Number(svg.getAttribute('height')||420);
    return [0,0,w,h];
  }

  function ensureClip(){
    if (!currentSVG) return;
    const [x,y,w,h] = readViewBox(currentSVG);
    if (!clampToViewBox) {
      // remove our clipPath if present
      const existing = currentSVG.querySelector('#__wbClip');
      if (existing && existing.parentNode) existing.parentNode.removeChild(existing);
      currentSVG.removeAttribute('clip-path');
      return;
    }

    // Put a defs/clipPath
    let defs = currentSVG.querySelector('defs');
    if (!defs) { defs = document.createElementNS('http://www.w3.org/2000/svg','defs'); currentSVG.prepend(defs); }

    let clip = currentSVG.querySelector('#__wbClip');
    if (!clip) {
      clip = document.createElementNS('http://www.w3.org/2000/svg','clipPath');
      clip.setAttribute('id','__wbClip');
      defs.appendChild(clip);
    }
    clip.replaceChildren(); // clear
    const r = document.createElementNS('http://www.w3.org/2000/svg','rect');
    r.setAttribute('x', x); r.setAttribute('y', y); r.setAttribute('width', w); r.setAttribute('height', h);
    clip.appendChild(r);

    // Apply at root level so everything stays inside workspace
    currentSVG.setAttribute('clip-path','url(#__wbClip)');
  }

  // Default sample so page isn't blank
  const defaultSVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 420 420">
  <rect width="420" height="420" fill="#fff"/>
  <text x="18" y="34" font-family="monospace" font-size="14" fill="#111">Paste or upload your createPhil SVG →</text>
  <circle cx="210" cy="210" r="80" fill="none" stroke="#111" stroke-width="3"/>
</svg>`;
  source.value = defaultSVG;
  setSVGFromText(defaultSVG); // records initial state
  updateHistoryButtons();

})();
</script>
</body>
</html>