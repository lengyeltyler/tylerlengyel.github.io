<!doctype html>
<html lang="en">
<head>
  <!-- PWA manifest + theme color -->
  <link rel="manifest" href="/snake/manifest.json">
  <meta name="theme-color" content="#0a0f0a">

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Snake</title>
  <meta name="description" content="Retro Snake ‚Äî arrow keys or WASD.">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <style>
    :root {
      --bg: #0a0f0a;
      --grid: #123312;
      --snake: #6cff6c;
      --snakeHead: #b3ffb3;
      --food: #a9ff3f;
      --ui: #d2ffd2;
      --accent: #4dff4d;
      --size: 20;   /* logical grid size; visual board stays constant now */
      --board-max: 480px; /* max visual size on larger screens */
      --cell: 24; /* kept for compatibility; no longer drives canvas pixels */
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: radial-gradient(80vw 80vh at 50% 40%, #0c150c 0%, var(--bg) 60%);
      color: var(--ui);
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      /* Stops iOS ‚Äúpull to refresh‚Äù/gestures from fighting gameplay; we re-enable vertical pan inside the card */
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
      overflow: hidden; /* page stays fixed; the card can scroll internally */
    }
    .wrap {
      min-height: 100%;
      display: grid;
      place-items: center;
      padding: 16px;
    }
    .card {
      width: min(94vw, calc(var(--board-max) + 32px));
      border: 1px solid #1c2a1c;
      background: rgba(5, 10, 5, 0.72);
      border-radius: 18px;
      padding: 16px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.4), inset 0 0 40px rgba(76,255,76,0.06);
      backdrop-filter: blur(4px);
      max-height: 100vh;          /* allow internal scroll if needed on small screens */
      overflow: auto;
      touch-action: pan-y;         /* allow vertical scroll INSIDE the card on mobile */
    }
    .topbar { display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; gap: 10px; flex-wrap: wrap; }
    .title { font-weight: 700; letter-spacing: 0.5px; }
    .stats { display: flex; gap: 12px; flex-wrap: wrap; }
    .pill {
      border: 1px solid #1e371e; border-radius: 999px; padding: 6px 10px; font-size: 14px;
      color: var(--accent); background: rgba(76,255,76,0.06);
    }

    /* CONSTANT visual board size: width clamps to viewport, stays square via aspect-ratio */
    canvas {
      width: min(94vw, var(--board-max));
      aspect-ratio: 1 / 1;        /* keeps it square without needing explicit height */
      image-rendering: pixelated;
      border-radius: 10px;
      border: 1px solid #1c2a1c;
      display: block;
      background: linear-gradient(#0b140b, #081008);
      margin: 0 auto;
      touch-action: none;
    }

    .controls {
      position: sticky; bottom: 8px; /* üí° stays visible near bottom even if the card scrolls */
      margin-top: 12px;
      display: grid;
      grid-template-columns: repeat(3, minmax(0,1fr));
      gap: 8px;
      user-select: none;
      padding-top: 8px;
      background: linear-gradient(to bottom, transparent, rgba(5,10,5,0.35));
      backdrop-filter: blur(2px);
    }
    .btn {
      border: 1px solid #1e371e; border-radius: 10px; padding: 12px 12px; text-align: center;
      background: rgba(76,255,76,0.06);
      color: var(--ui); font-weight: 600; cursor: pointer;
      transition: transform .04s ease, background .1s ease;
      touch-action: manipulation;
    }
    .btn:active { transform: translateY(1px) scale(.99); background: rgba(76,255,76,0.12); }
    .grid-spacer { visibility: hidden; }
    .help { margin-top: 10px; font-size: 13px; opacity: .8; line-height: 1.4; }
    .linkbar { margin-top: 8px; font-size: 13px; opacity: .75; }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }

    /* Scoreboard */
    .board {
      margin-top: 14px;
      border-top: 1px solid #1c2a1c;
      padding-top: 12px;
    }
    .board h3 { margin: 0 0 8px 0; font-size: 14px; letter-spacing: .4px; opacity: .9; }
    .scores { display: grid; grid-template-columns: 1.5fr .8fr .8fr .9fr; gap: 6px 10px; font-size: 13px; }
    .scores div { padding: 6px 8px; background: rgba(76,255,76,0.04); border: 1px solid #1e371e; border-radius: 8px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .scores .hdr { font-weight: 700; background: rgba(76,255,76,0.08); }

    /* Mobile tweaks: slightly larger buttons */
    @media (max-width: 480px) {
      .btn { padding: 16px 18px; font-size: 18px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="topbar">
        <div class="title">S N A K E</div>
        <div class="stats">
          <div class="pill">Score: <span id="score">0</span></div>
          <div class="pill">High: <span id="high">0</span></div>
          <div class="pill">Level: <span id="level">1</span>/69</div>
          <div class="pill">Speed: <span id="speedLabel">Normal</span></div>
          <div class="pill" id="stateLabel">Playing</div>
        </div>
      </div>

      <canvas id="board" width="480" height="480" aria-label="Snake game area" role="img"></canvas>

      <!-- Touch controls (sticky so DOWN stays visible) -->
      <div class="controls" aria-hidden="false">
        <div class="grid-spacer"></div>
        <button class="btn" data-dir="up">‚ñ≤ Up</button>
        <div class="grid-spacer"></div>
        <button class="btn" data-dir="left">‚óÄ Left</button>
        <button class="btn" id="pauseBtn">‚è∏ / ‚ñ∂</button>
        <button class="btn" data-dir="right">‚ñ∂ Right</button>
        <div class="grid-spacer"></div>
        <button class="btn" data-dir="down">‚ñº Down</button>
        <div class="grid-spacer"></div>
      </div>

      <div class="help">
        Controls: Arrow Keys / WASD. Space or P = Pause/Resume. R = Restart. + / ‚Äì = Speed.
        <br>Wrap-around edges, 69 levels (grid grows), Top-10 scoreboard, offline-ready PWA.
      </div>

      <div class="linkbar">
        <a href="/" rel="home">‚Üê Back to Home</a>
      </div>

      <div class="board">
        <h3>Top Scores</h3>
        <div class="scores" id="scoresGrid">
          <div class="hdr">Name</div><div class="hdr">Score</div><div class="hdr">Level</div><div class="hdr">Date</div>
          <!-- rows injected here -->
        </div>
      </div>
    </div>
  </div>

  <script>
    // ====== Config ======
    const BASE_SIZE = 16;              // Level 1 grid (cells per side)
    const MAX_LEVEL = 69;              // Levels 1..69
    const CELLS_PER_LEVEL = 1;         // +1 cell per side each level
    const CELLS_PER_FOOD_FOR_LEVEL = 5;// Level up every 5 foods

    // CONSTANT internal canvas resolution (keeps visual size constant)
    const CANVAS_PX = 480;

    const SPEEDS = [
      { label: "Chill",  ms: 160 },
      { label: "Normal", ms: 120 },
      { label: "Snappy", ms:  90 },
      { label: "Turbo",  ms:  65 }
    ];
    // Auto mobile mode: start slower on touch/coarse pointers
    let speedIndex = matchMedia("(pointer: coarse)").matches ? 0 : 1;

    const STORAGE_HIGH   = "snake_highscore_v1";
    const STORAGE_BOARD  = "snake_scoreboard_v1";

    // ====== DOM ======
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d', { alpha: false });
    const scoreEl = document.getElementById('score');
    const highEl  = document.getElementById('high');
    const levelEl = document.getElementById('level');
    const speedLabel = document.getElementById('speedLabel');
    const stateLabel = document.getElementById('stateLabel');
    const pauseBtn = document.getElementById('pauseBtn');
    const scoresGrid = document.getElementById('scoresGrid');

    // Ensure internal canvas resolution is constant (matches attribute width/height)
    canvas.width = CANVAS_PX;
    canvas.height = CANVAS_PX;

    // ====== Game State ======
    let SIZE;            // logical grid size (cells per side)
    let snake, direction, nextDirection, food, score, high, alive, paused, lastTick;
    let level, foodsThisLevel;

    // Dynamic cell size derived from constant canvas size
    function cellPx() { return Math.floor(CANVAS_PX / SIZE); }

    // ====== Scoreboard ======
    function readBoard() {
      try { const raw = localStorage.getItem(STORAGE_BOARD); return raw ? JSON.parse(raw) : []; }
      catch { return []; }
    }
    function writeBoard(list) { try { localStorage.setItem(STORAGE_BOARD, JSON.stringify(list)); } catch {} }
    function addScoreToBoard(name, score, level) {
      const list = readBoard();
      list.push({ name: (name || "Player").trim().slice(0,24) || "Player", score, level, ts: Date.now() });
      list.sort((a,b) => b.score - a.score || b.ts - a.ts);
      const top = list.slice(0, 10);
      writeBoard(top);
      renderBoard(top);
    }
    function renderBoard(list = readBoard()) {
      while (scoresGrid.children.length > 4) scoresGrid.removeChild(scoresGrid.lastChild);
      for (const row of list) {
        const d = new Date(row.ts);
        const date = d.toLocaleDateString(undefined, { month:'short', day:'2-digit' });
        for (const c of [row.name, String(row.score), String(row.level), date]) {
          const div = document.createElement('div'); div.textContent = c; scoresGrid.appendChild(div);
        }
      }
    }

    // ====== High score ======
    function loadHigh() {
      const v = parseInt(localStorage.getItem(STORAGE_HIGH) || "0", 10);
      high = isNaN(v) ? 0 : v; highEl.textContent = high;
    }
    function saveHigh() {
      if (score > high) { high = score; highEl.textContent = high; localStorage.setItem(STORAGE_HIGH, String(high)); }
    }

    // ====== Level / Size ======
    function sizeForLevel(lv) { return BASE_SIZE + (lv - 1) * CELLS_PER_LEVEL; }
    function applySizeVars() {
      document.documentElement.style.setProperty('--size', String(SIZE));
      // canvas remains constant; only cell size changes via cellPx()
    }
    function setLevel(lv) {
      level = Math.max(1, Math.min(MAX_LEVEL, lv));
      SIZE = sizeForLevel(level);
      applySizeVars();
      levelEl.textContent = level;
      speedLabel.textContent = SPEEDS[speedIndex].label;
      foodsThisLevel = 0;
    }
    function maybeLevelUp() {
      if (level >= MAX_LEVEL) return;
      if (foodsThisLevel >= CELLS_PER_FOOD_FOR_LEVEL) {
        level++;
        setLevel(level);
        if (level % 4 === 0 && speedIndex < SPEEDS.length - 1) {
          speedIndex++; speedLabel.textContent = SPEEDS[speedIndex].label;
        }
      }
    }

    // ====== Game Core ======
    function reset() {
      setLevel(1);
      snake = [
        { x: Math.floor(SIZE/2), y: Math.floor(SIZE/2) },
        { x: Math.floor(SIZE/2)-1, y: Math.floor(SIZE/2) },
        { x: Math.floor(SIZE/2)-2, y: Math.floor(SIZE/2) }
      ];
      direction = { x: 1, y: 0 };
      nextDirection = { x: 1, y: 0 };
      score = 0; alive = true; paused = false; lastTick = 0;
      placeFood();
      scoreEl.textContent = score;
      stateLabel.textContent = "Playing";
      renderBoard();
    }

    function placeFood() {
      while (true) {
        const x = Math.floor(Math.random() * SIZE);
        const y = Math.floor(Math.random() * SIZE);
        if (!snake.some(s => s.x === x && s.y === y)) { food = { x, y }; return; }
      }
    }

    function setDirection(dx, dy) {
      if (dx === -direction.x && dy === -direction.y) return;
      nextDirection = { x: dx, y: dy };
    }

    // ====== Draw ======
    function draw() {
      const cp = cellPx();
      const px = cp * SIZE; // may be slightly smaller than CANVAS_PX due to floor; center it
      const offset = Math.floor((CANVAS_PX - px) / 2);

      // Background
      ctx.fillStyle = getVar('--bg');
      ctx.fillRect(0, 0, CANVAS_PX, CANVAS_PX);

      // Subtle grid (centered)
      ctx.strokeStyle = getVar('--grid'); ctx.lineWidth = 1;
      ctx.beginPath();
      for (let i = 1; i < SIZE; i++) {
        const g = offset + i * cp + 0.5;
        ctx.moveTo(g, offset);           ctx.lineTo(g, offset + px);
        ctx.moveTo(offset, g);           ctx.lineTo(offset + px, g);
      }
      ctx.stroke();

      // Food
      fillCell(food.x, food.y, getVar('--food'), cp, offset);
      // Snake
      for (let i = 0; i < snake.length; i++) {
        const seg = snake[i];
        fillCell(seg.x, seg.y, i === 0 ? getVar('--snakeHead') : getVar('--snake'), cp, offset);
      }
    }

    function fillCell(x, y, color, cp, offset) {
      ctx.fillStyle = color;
      ctx.fillRect(offset + x * cp, offset + y * cp, cp, cp);
    }
    function getVar(name) { return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

    // ====== Tick / Logic (wrap-around walls) ======
    function step(ts) {
      if (!alive) { draw(); return; }
      if (paused)  { draw(); requestAnimationFrame(step); return; }

      if (!lastTick) lastTick = ts;
      const delta = ts - lastTick;
      const interval = SPEEDS[speedIndex].ms;
      if (delta >= interval) {
        lastTick = ts;

        direction = nextDirection;
        const head = snake[0];
        let nx = head.x + direction.x;
        let ny = head.y + direction.y;

        // Wrap-around instead of wall death:
        if (nx < 0) nx = SIZE - 1; else if (nx >= SIZE) nx = 0;
        if (ny < 0) ny = SIZE - 1; else if (ny >= SIZE) ny = 0;

        // Self collision = game over
        if (snake.some(s => s.x === nx && s.y === ny)) {
          alive = false;
          stateLabel.textContent = "Game Over";
          saveHigh();
          draw();
          setTimeout(() => {
            const name = prompt("Game Over! Enter your name for the scoreboard:", "");
            addScoreToBoard(name || "Player", score, level);
          }, 30);
          requestAnimationFrame(step);
          return;
        }

        snake.unshift({ x: nx, y: ny });

        if (nx === food.x && ny === food.y) {
          score += 1; foodsThisLevel += 1;
          scoreEl.textContent = score;
          placeFood();
          maybeLevelUp();
        } else {
          snake.pop();
        }
      }

      draw();
      requestAnimationFrame(step);
    }

    // ====== Input (keys + buttons + swipe) ======
    window.addEventListener('keydown', (e) => {
      const k = e.key.toLowerCase();
      let handled = false;
      if (k === 'arrowup' || k === 'w')      { setDirection(0, -1); handled = true; }
      else if (k === 'arrowdown' || k === 's'){ setDirection(0, 1);  handled = true; }
      else if (k === 'arrowleft' || k === 'a'){ setDirection(-1, 0); handled = true; }
      else if (k === 'arrowright' || k === 'd'){setDirection(1, 0);  handled = true; }
      else if (k === ' ' || k === 'p')        { togglePause();       handled = true; }
      else if (k === 'r')                     { reset();             handled = true; }
      else if (k === '+' || k === '=')        { changeSpeed(1);      handled = true; }
      else if (k === '-' || k === '_')        { changeSpeed(-1);     handled = true; }
      if (handled) { e.preventDefault(); } // üõë stop page scrolling on arrows/space
    }, { passive: false });

    document.querySelectorAll('[data-dir]').forEach(btn => {
      btn.addEventListener('click', () => {
        const d = btn.getAttribute('data-dir');
        if (d === 'up') setDirection(0, -1);
        if (d === 'down') setDirection(0, 1);
        if (d === 'left') setDirection(-1, 0);
        if (d === 'right') setDirection(1, 0);
      });
    });
    pauseBtn.addEventListener('click', togglePause);

    // Swipe control on the canvas
    (function() {
      const el = canvas;
      let startX=0, startY=0, active=false;
      const minDist = 18; // px threshold
      el.addEventListener('touchstart', (e) => {
        const t = e.changedTouches[0];
        startX = t.clientX; startY = t.clientY; active = true;
      }, {passive: true});
      el.addEventListener('touchend', (e) => {
        if (!active) return; active = false;
        const t = e.changedTouches[0];
        const dx = t.clientX - startX;
        const dy = t.clientY - startY;
        if (Math.max(Math.abs(dx), Math.abs(dy)) < minDist) return;
        if (Math.abs(dx) > Math.abs(dy)) {
          if (dx > 0) setDirection(1, 0);
          else setDirection(-1, 0);
        } else {
          if (dy > 0) setDirection(0, 1);
          else setDirection(0, -1);
        }
      }, {passive: true});
    })();

    function togglePause() {
      paused = !paused;
      stateLabel.textContent = paused ? "Paused" : "Playing";
    }
    function changeSpeed(delta) {
      const prev = speedIndex;
      speedIndex = Math.max(0, Math.min(SPEEDS.length - 1, speedIndex + delta));
      if (speedIndex !== prev) speedLabel.textContent = SPEEDS[speedIndex].label;
    }

    // ====== Boot ======
    loadHigh();
    renderBoard();
    reset();
    draw();
    requestAnimationFrame(step);
    document.addEventListener('visibilitychange', () => { lastTick = 0; }, { passive: true });

    // ====== PWA: register service worker ======
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker.register("/snake/service-worker.js");
      });
    }
  </script>
</body>
</html>