<!doctype html>
<html lang="en">
<head>
  <!-- PWA -->
  <link rel="manifest" href="/nakes/manifest.json">
  <meta name="theme-color" content="#0a0f0a">
  <!-- iOS standalone feel when added to Home Screen -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

  <meta charset="utf-8" />
  <title>nakes</title>
  <meta name="description" content="Retro nakes ‚Äî keyboard, swipe, and D-pad." />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <style>
    :root{
      --bg:#0a0f0a; --grid:#123312; --nakes:#6cff6c; --nakesHead:#b3ffb3; --food:#a9ff3f;
      --ui:#d2ffd2; --accent:#4dff4d;
      --size:20;                   /* logical grid size (changes with level) */
      --desktop-max:560px;         /* desktop max visual width */
      --gap:12px;
      --safe-top: env(safe-area-inset-top);
      --safe-right: env(safe-area-inset-right);
      --safe-bottom: env(safe-area-inset-bottom);
      --safe-left: env(safe-area-inset-left);
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{
      background:radial-gradient(80vw 80vh at 50% 40%, #0c150c 0%, var(--bg) 60%);
      color:var(--ui);
      font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
      touch-action:none;
      -webkit-user-select:none; user-select:none;
      overflow:hidden;                /* no page scroll; app fills viewport */
    }

    /* ===== App-like layout (fills the screen) ===== */
    .app{
      position:fixed; inset:0;
      padding:calc(var(--safe-top) + 8px) calc(var(--safe-right) + 8px)
              calc(var(--safe-bottom) + 8px) calc(var(--safe-left) + 8px);
      display:grid; grid-template-rows: 1fr auto; gap: var(--gap);
      max-width:min(100vw,100svw); max-height:min(100vh,100svh);
    }

    /* HUD overlays canvas by default (desktop) so it doesn't consume vertical space */
    .hud{
      position:absolute; left:0; right:0; top:8px;
      padding:0 8px;
      display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap;
      pointer-events:none; /* don't block canvas touches */
    }
    .title{font-weight:700; letter-spacing:.5px; text-shadow:0 2px 8px rgba(76,255,76,.15)}
    .stats{display:flex; gap:8px; flex-wrap:wrap}
    .pill{
      pointer-events:auto;
      border:1px solid #1e371e; border-radius:999px; padding:4px 8px; font-size:13px;
      color:var(--accent); background:rgba(76,255,76,.06)
    }

    .stage{ position:relative; display:grid; place-items:center; min-height:0; }

    /* Canvas auto-sizes to space above controls; crisp via DPR scaling in JS */
    canvas{
      display:block; width:100%; height:auto; max-width:var(--desktop-max);
      aspect-ratio:1/1;
      border:1px solid #1c2a1c; border-radius:12px;
      background:linear-gradient(#0b140b,#081008);
      image-rendering: pixelated;
      touch-action:none;
    }

    /* D-pad: always visible bottom row */
    .controls{
      display:grid; grid-template-columns:repeat(3,minmax(0,1fr)); gap:8px;
      max-width:var(--desktop-max); margin:0 auto;
      padding-bottom:2px;
    }
    .btn{
      border:1px solid #1e371e; border-radius:12px; padding:14px 12px; text-align:center;
      background:rgba(76,255,76,.06); color:var(--ui); font-weight:700; cursor:pointer;
      transition:transform .04s ease, background .1s ease; touch-action:manipulation; font-size:18px;
    }
    .btn:active{transform:translateY(1px) scale(.99); background:rgba(76,255,76,.12)}
    .grid-spacer{visibility:hidden}
    .controls .full { grid-column: 1 / -1; } /* Speed button spans all columns */

    /* Small desktop-only extras under the D-pad */
    .extras{max-width:var(--desktop-max); margin:8px auto 0}
    .help{font-size:13px; opacity:.8; margin-bottom:6px}
    .linkbar a{color:var(--accent); text-decoration:none}
    .linkbar a:hover{text-decoration:underline}

    /* ===== Mobile tweaks ===== */
    @media (max-width: 640px){
      .hud{
        position: static; inset: auto; padding: 0 2px 4px 2px; display: block; pointer-events: auto;
      }
      .title{ font-size: 14px; margin-bottom: 2px; }
      .stats{ display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 4px 6px; }
      .pill{ font-size: 11px; padding: 2px 6px; border-radius: 8px; background: transparent; border-color: #184e18; color: #86ff86; }
      .btn{ padding: 12px; font-size: 16px; border-radius: 10px; }
      .controls{ gap: 6px; }
      .extras{ display: none; }   /* no scrolling on phones */
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="stage">
      <div class="hud">
        <div class="title">S N A K E</div>
        <div class="stats">
          <div class="pill">Score: <span id="score">0</span></div>
          <div class="pill">High: <span id="high">0</span></div>
          <div class="pill">Level: <span id="level">1</span>/69</div>
          <div class="pill">Speed: <span id="speedLabel">Normal</span></div>
          <div class="pill" id="stateLabel">Playing</div>
        </div>
      </div>
      <canvas id="board" aria-label="nakes game area" role="img"></canvas>
    </div>

    <!-- D-pad -->
    <div>
      <div class="controls">
        <div class="grid-spacer"></div>
        <button class="btn" data-dir="up">‚ñ≤ Up</button>
        <div class="grid-spacer"></div>

        <button class="btn" data-dir="left">‚óÄ Left</button>
        <button class="btn" id="pauseBtn">‚è∏ / ‚ñ∂</button>
        <button class="btn" data-dir="right">‚ñ∂ Right</button>

        <div class="grid-spacer"></div>
        <button class="btn" data-dir="down">‚ñº Down</button>
        <div class="grid-spacer"></div>

        <!-- Speed cycles Chill ‚Üí Normal ‚Üí Snappy ‚Üí Turbo -->
        <button class="btn full" id="speedBtn" aria-label="Change speed">
          Speed: <span id="speedBtnLabel">Normal</span>
        </button>
        <a class="btn full" id="scoresBtn" href="/nakes/leaderboard.html" role="button" style="display:inline-block; text-decoration:none; text-align:center;">
          üèÜ Leaderboard
        </a>
      </div>

      <!-- ONE light extras block (no embedded table) -->
      <div class="extras">
        <div class="help">
          Keys: Arrows/WASD. Space/P = Pause. R = Restart. + / ‚Äì = Speed.
          Wrap edges ‚Ä¢ 69 levels ‚Ä¢ Top-10 scoreboard ‚Ä¢ Offline PWA.
        </div>

        <!-- ‚úÖ Prize widget container -->
        <div id="prize-root" style="margin:8px 0"></div>

        <div class="linkbar">
          <a href="/" rel="home">‚Üê Back to Home</a> ¬∑
          <a href="/nakes/leaderboard.html">Leaderboard</a>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ====== Config ======
    const BASE_SIZE=16, MAX_LEVEL=69, CELLS_PER_LEVEL=1, CELLS_PER_FOOD_FOR_LEVEL=5;
    const SPEEDS=[{label:"Chill",ms:160},{label:"Normal",ms:120},{label:"Snappy",ms:90},{label:"Turbo",ms:65}];
    let speedIndex = matchMedia("(pointer: coarse)").matches ? 0 : 1;

    // Cloudflare Worker API (existing global scoreboard)
    const GLOBAL_API = "https://score.tylerlengyel.com/api";

    // ====== DOM ======
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d', { alpha:false });
    const scoreEl = document.getElementById('score');
    const highEl = document.getElementById('high');
    const levelEl = document.getElementById('level');
    const speedLabel = document.getElementById('speedLabel');
    const stateLabel = document.getElementById('stateLabel');
    const pauseBtn = document.getElementById('pauseBtn');
    const speedBtn = document.getElementById('speedBtn');
    const speedBtnLabel = document.getElementById('speedBtnLabel');

    // ====== Game State ======
    let SIZE, nakes, direction, nextDirection, food, score, high, alive, paused, lastTick, level, foodsThisLevel;
    let LOGICAL_PX=480, DPR=1;
    function getVar(n){return getComputedStyle(document.documentElement).getPropertyValue(n).trim();}
    function cellPx(){ return Math.floor(LOGICAL_PX / SIZE); }

    // ====== Local scores (for offline) ======
    const STORAGE_HIGH="nakes_highscore_v1", STORAGE_BOARD="nakes_scoreboard_v1";
    function readBoard(){ try{const raw=localStorage.getItem(STORAGE_BOARD); return raw?JSON.parse(raw):[]}catch{return[]}}
    function writeBoard(list){ try{localStorage.setItem(STORAGE_BOARD, JSON.stringify(list))}catch{} }
    function addScoreToBoard(name,score,level){
      const list=readBoard(); list.push({name:(name||"Player").trim().slice(0,24)||"Player",score,level,ts:Date.now()});
      list.sort((a,b)=>b.score-a.score||b.ts-a.ts); writeBoard(list.slice(0,10));
    }
    async function submitGlobalScore(name, score, level){
      if(!GLOBAL_API) return;
      try{
        await fetch(`${GLOBAL_API}/submit`,{
          method:"POST",
          headers:{ "Content-Type":"application/json" },
          body: JSON.stringify({ name, score, level })
        });
      }catch{}
    }

    // ====== High score ======
    function loadHigh(){ const v=parseInt(localStorage.getItem(STORAGE_HIGH)||"0",10); high=isNaN(v)?0:v; highEl.textContent=high; }
    function saveHigh(){ if(score>high){ high=score; highEl.textContent=high; localStorage.setItem(STORAGE_HIGH, String(high)); } }

    // ====== Level / Size ======
    function sizeForLevel(lv){ return BASE_SIZE + (lv-1)*CELLS_PER_LEVEL; }
    function applySizeVars(){ document.documentElement.style.setProperty('--size', String(SIZE)); }
    function setLevel(lv){
      level=Math.max(1,Math.min(MAX_LEVEL,lv));
      SIZE=sizeForLevel(level);
      applySizeVars();
      levelEl.textContent=level;
      speedLabel.textContent=SPEEDS[speedIndex].label;
      if (speedBtnLabel) speedBtnLabel.textContent = SPEEDS[speedIndex].label;
      foodsThisLevel=0;
    }
    function maybeLevelUp(){
      if(level>=MAX_LEVEL) return;
      if(foodsThisLevel>=CELLS_PER_FOOD_FOR_LEVEL){
        setLevel(level+1);
        if(level%4===0 && speedIndex<SPEEDS.length-1){
          speedIndex++; speedLabel.textContent=SPEEDS[speedIndex].label;
          if (speedBtnLabel) speedBtnLabel.textContent = SPEEDS[speedIndex].label;
        }
      }
    }

    // ====== Layout: square canvas sized to available space, crisp on DPR
    function layout(){
      const app = document.querySelector('.app');
      const controls = document.querySelector('.controls');
      const extras = document.querySelector('.extras');
      const hud = document.querySelector('.hud');

      const appW = app.clientWidth;
      const appH = app.clientHeight;

      const ctrH = controls.offsetHeight + 8;                // always subtract D-pad
      const extraH = extras && getComputedStyle(extras).display !== 'none'
        ? extras.offsetHeight + 8                              // subtract extras on desktop
        : 0;
      const hudIsOverlay = getComputedStyle(hud).position === 'absolute';
      const hudH = hudIsOverlay ? 0 : (hud.offsetHeight + 6); // subtract HUD only when above canvas (mobile)

      const size = Math.min(appW, appH - ctrH - extraH - hudH);
      const cssSize = Math.max(240, size); // minimum so it never gets too tiny

      // Set only width; height comes from aspect-ratio so it stays perfectly square
      canvas.style.width = cssSize + "px";
      canvas.style.height = ""; // let CSS handle it

      // Measure the *actual* rendered width to size the backing buffer
      const rectW = Math.floor(canvas.getBoundingClientRect().width);
      LOGICAL_PX = rectW;

      DPR = Math.max(1, window.devicePixelRatio || 1);
      canvas.width  = Math.floor(LOGICAL_PX * DPR);
      canvas.height = Math.floor(LOGICAL_PX * DPR);
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    }
    window.addEventListener('resize', layout, {passive:true});
    window.addEventListener('orientationchange', layout, {passive:true});

    // ====== Core ======
    function reset(){
      setLevel(1);
      nakes=[
        {x:Math.floor(SIZE/2), y:Math.floor(SIZE/2)},
        {x:Math.floor(SIZE/2)-1, y:Math.floor(SIZE/2)},
        {x:Math.floor(SIZE/2)-2, y:Math.floor(SIZE/2)}
      ];
      direction={x:1,y:0}; nextDirection={x:1,y:0};
      score=0; alive=true; paused=false; lastTick=0;
      placeFood(); scoreEl.textContent=score; stateLabel.textContent="Playing";
    }
    function placeFood(){
      while(true){
        const x=Math.floor(Math.random()*SIZE), y=Math.floor(Math.random()*SIZE);
        if(!nakes.some(s=>s.x===x && s.y===y)){ food={x,y}; return; }
      }
    }
    function setDirection(dx,dy){ if(dx===-direction.x && dy===-direction.y) return; nextDirection={x:dx,y:dy}; }

    function draw(){
      const cp=cellPx(), px=cp*SIZE, offset=Math.floor((LOGICAL_PX - px)/2);
      ctx.fillStyle=getVar('--bg'); ctx.fillRect(0,0,LOGICAL_PX,LOGICAL_PX);
      ctx.strokeStyle=getVar('--grid'); ctx.lineWidth=1; ctx.beginPath();
      for(let i=1;i<SIZE;i++){ const g=offset+i*cp+0.5; ctx.moveTo(g,offset); ctx.lineTo(g,offset+px); ctx.moveTo(offset,g); ctx.lineTo(offset+px,g); }
      ctx.stroke();
      fillCell(food.x,food.y,getVar('--food'),cp,offset);
      for(let i=0;i<nakes.length;i++){ const seg=nakes[i]; fillCell(seg.x,seg.y, i===0?getVar('--nakesHead'):getVar('--nakes'),cp,offset); }
    }
    function fillCell(x,y,color,cp,offset){ ctx.fillStyle=color; ctx.fillRect(offset + x*cp, offset + y*cp, cp, cp); }

    function step(ts){
      if(!alive){ draw(); return; }
      if(paused){ draw(); requestAnimationFrame(step); return; }
      if(!lastTick) lastTick=ts;
      const interval=SPEEDS[speedIndex].ms;
      if(ts-lastTick>=interval){
        lastTick=ts;
        direction=nextDirection;
        const head=nakes[0];
        let nx=head.x+direction.x, ny=head.y+direction.y;
        // wrap
        if(nx<0) nx=SIZE-1; else if(nx>=SIZE) nx=0;
        if(ny<0) ny=SIZE-1; else if(ny>=SIZE) ny=0;
        // self collision
        if(nakes.some(s=>s.x===nx && s.y===ny)){
          alive=false; stateLabel.textContent="Game Over"; saveHigh(); draw();
          setTimeout(()=>{
            const name=prompt("Game Over! Enter your name for the leaderboard:", "") || "Player";
            addScoreToBoard(name, score, level);   // local (offline)
            submitGlobalScore(name, score, level); // global (online)
            window.__sendPrize?.(level);           // ‚úÖ trigger prize flow (non-blocking)
          }, 20);
          requestAnimationFrame(step); return;
        }
        nakes.unshift({x:nx,y:ny});
        if(nx===food.x && ny===food.y){
          score+=1; foodsThisLevel+=1; scoreEl.textContent=score; placeFood(); maybeLevelUp();
        }else{
          nakes.pop();
        }
      }
      draw(); requestAnimationFrame(step);
    }

    // ====== Input (keys + buttons + swipe) ======
    window.addEventListener('keydown', (e)=>{
      const k=e.key.toLowerCase(); let handled=false;
      if(k==='arrowup'||k==='w'){ setDirection(0,-1); handled=true; }
      else if(k==='arrowdown'||k==='s'){ setDirection(0,1); handled=true; }
      else if(k==='arrowleft'||k==='a'){ setDirection(-1,0); handled=true; }
      else if(k==='arrowright'||k==='d'){ setDirection(1,0); handled=true; }
      else if(k===' '||k==='p'){ togglePause(); handled=true; }
      else if(k==='r'){ reset(); handled=true; }
      else if(k==='+'||k==='='){ changeSpeed(1); handled=true; }
      else if(k==='-'||k==='_'){ changeSpeed(-1); handled=true; }
      if(handled) e.preventDefault(); // stop page scroll on arrows/space
    }, {passive:false});

    document.querySelectorAll('[data-dir]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const d=btn.getAttribute('data-dir');
        if(d==='up') setDirection(0,-1);
        if(d==='down') setDirection(0,1);
        if(d==='left') setDirection(-1,0);
        if(d==='right') setDirection(1,0);
      });
    });
    if (pauseBtn) pauseBtn.addEventListener('click', togglePause);

    // swipe on canvas
    (function(){
      const el=canvas; let startX=0,startY=0,active=false; const minDist=18;
      el.addEventListener('touchstart', e=>{ const t=e.changedTouches[0]; startX=t.clientX; startY=t.clientY; active=true; }, {passive:true});
      el.addEventListener('touchend', e=>{
        if(!active) return; active=false; const t=e.changedTouches[0];
        const dx=t.clientX-startX, dy=t.clientY-startY;
        if(Math.max(Math.abs(dx),Math.abs(dy))<minDist) return;
        if(Math.abs(dx)>Math.abs(dy)){ setDirection(dx>0?1:-1,0); } else { setDirection(0,dy>0?1:-1); }
      }, {passive:true});
    })();

    function togglePause(){ paused=!paused; stateLabel.textContent=paused?"Paused":"Playing"; }
    function changeSpeed(delta){
      const prev=speedIndex;
      speedIndex=Math.max(0,Math.min(SPEEDS.length-1,speedIndex+delta));
      if(speedIndex!==prev){
        speedLabel.textContent=SPEEDS[speedIndex].label;
        if (speedBtnLabel) speedBtnLabel.textContent = SPEEDS[speedIndex].label;
      }
    }
    if (speedBtn) speedBtn.addEventListener('click', ()=> changeSpeed(1));

    // ====== Boot ======
    function boot(){
      layout();
      loadHigh();
      reset();
      draw();
      requestAnimationFrame(step);
    }
    window.addEventListener('load', boot, {passive:true});
    document.addEventListener('visibilitychange', ()=>{ lastTick=0; }, {passive:true});
    window.addEventListener('resize', ()=>{ lastTick=0; }, {passive:true});

    // ====== Service worker ======
    if('serviceWorker' in navigator){
      window.addEventListener('load', ()=> navigator.serviceWorker.register('/nakes/service-worker.js'));
    }
  </script>

  <!-- ‚úÖ Prize module: mounts widget and exposes window.__sendPrize -->
  <script type="module">
    import { mountPrizeWidget, prizeFinish } from "/nakes/prize.js";
    mountPrizeWidget("#prize-root");
    window.__sendPrize = async (finalLevel) => {
      try {
        const res = await prizeFinish(finalLevel);
        console.log("[Prize] result:", res);
      } catch (e) {
        console.warn("[Prize] error:", e);
      }
    };
  </script>
</body>
</html>